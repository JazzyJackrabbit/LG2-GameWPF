using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Threading;
using static LaserGame.MainWindow;

namespace LaserGame
{
    public class Game
    {

        string public3I_Ip = "";
        public List<Player> players = new List<Player>();
        private readonly int ipStart = 2;
        private readonly string node_ESP_COM_repository = @"P:\ARCHIVE\Dev\LASER GAME\server\ESP_Com";
        public DispatcherTimer timer = new DispatcherTimer();
        public int timerCountdownSec = 0;
        int timeGame = 0;

        public bool start = false;

        public Game(string _publicIp)
        {
            public3I_Ip = to3I_Ip(_publicIp);
            timer.Tick += timer_Tick;
            init();
        }

        void timer_Tick(object sender, EventArgs e)
        {
            if (start)
            {

                if(timerCountdownSec <= 0)
                    gameJustStopping_Tick();
                
                else if (timerCountdownSec == timeGame)
                    gameJustStarting_Tick();
                
                if (timerCountdownSec <= timeGame)
                    gameOn_Tick();

                timerCountdownSec -= 1;

            }
        }


        private void gameJustStopping_Tick()
        {
            Stop();
        }
        private void gameJustStarting_Tick()
        {
            command_ESP_ComAsync_AllPlayers("START"); // everyone
        }
        private void gameOn_Tick()
        {

            command_ESP_ComAsync_AllPlayers("GET_BUFFER");
        }
        private void actionOnCommand_Tick(Player _player, string cmd, string resultOutput)
        {
            if(cmd == "GET_BUFFER")
            {
                // replace buffer
                if (_player.last_buffer.Length > resultOutput.Length)
                {
                    _player.last_buffer = resultOutput;
                    List<Player> killers = bufferToKillers(resultOutput);

                    _player.death = killers.Count;

                }
                   


            }
        }

        private List<Player> bufferToKills(string _resultOutput)
        {
            List<Player> killers = new List<Player>();


        }

        internal void init()
        {
            players = new List<Player>();

            timer.Interval = TimeSpan.FromSeconds(1);
            timer.Start();
        }

        internal void Start(int _timeSecGlobal, int _timeSecGame)
        {
            timerCountdownSec = _timeSecGlobal;
            timeGame = _timeSecGame;

            start = true;
            timer.Start();
        }

        internal void Stop()
        {
            command_ESP_ComAsync_AllPlayers("STOP"); // everyone

            timerCountdownSec = 0;
            start = false;
            timer.Stop();
        }

        public void createPlayer(GridLine _gl)
        {
            string _pseudo = _gl.Pseudo;
            string _color = _gl.Team;

            // asign ip player
            int ip = getFreeIp();

            Player p = new Player(ip, _pseudo, _color);
            _gl.playerRef = p;
            p.gridlineRef = _gl;
            players.Add(p);

            // init player
            command_ESP_ComAsync("INIT", p);

            // get id player
            Task<string> idPlayerOutputTask = command_ESP_Com_SYNC("GET_ID", ip);

            // set color
            if (_color == "RED") command_ESP_ComAsync("RED", p);
            else if (_color == "BLUE") command_ESP_ComAsync("BLUE", p);
            else command_ESP_ComAsync("NO_COLOR", p);

            idPlayerOutputTask.Wait();

            string idPlayerOutput = idPlayerOutputTask.Result;

            if (idPlayerOutput == null) p.id = -1;
            else
                if (idPlayerOutput.Length > 0)
            {
                try
                {
                    p.id = Convert.ToInt32(idPlayerOutput);
                }
                catch
                {
                    p.id = -1;
                }
            }
            else p.id = 0;

            _gl.Pseudo = ip + ":" + (p.id) + ". " + _gl.Pseudo;

        }

        private int getFreeIp()
        {
            int z = 0;
            for (z = 0; z < players.Count; z++)
            {
                Player playerF = players[z];
                if ( !checkIpExist(z + ipStart) ) return z + ipStart;
            }
            return z + ipStart;
        }

        private bool checkIpExist(int _ip)
        {
            for (int z = 0; z < players.Count; z++)
            {
                if(players[z] != null)
                    if (players[z].getSubIpAddr() == _ip)
                    {
                        return true;
                    }
            }
            return false;
        }

        public void deletePlayer(Player _playerToDelete)
        {
            players.Remove(_playerToDelete);
            _playerToDelete.gridlineRef = null;
            _playerToDelete = null;

        }


        private string to3I_Ip(string ip)
        {
            try
            {
                string[] w = ip.Split('.');
                return w[0] + "." + w[1] + "." + w[2] + ".";
            }
            catch { }
            return "";
        }

        delegate string ReadLineDelegate();

        public async void command_ESP_ComAsync(string _cmd, Player _p)  //  cmd_<NAMEFILE>  ,    _subIp  0 = *
        {

            int _timeout = 1000;
            Task.Run(() => timedCommandVoid(_cmd, _p, _timeout));

        }

        public async void command_ESP_ComAsync_AllPlayers(string _cmd)  //  cmd_<NAMEFILE>  ,    _subIp  0 = *
        {
            int _timeout = 1000;
            foreach (Player p in players)
                Task.Run(() => timedCommandVoid(_cmd, p, _timeout));

        }

        private void timedCommandVoid(string _cmd, Player _p, int _timeout)
        {
            string resultOutput = timedCommand(_cmd, _p.subIpAddr, _timeout);
            actionOnCommand_Tick(_p, _cmd, resultOutput);
        }

        public async Task<string> command_ESP_Com_SYNC(string _cmd, int _subIp)
        {
            int _timeout = 1000;
            return timedCommand(_cmd, _subIp, _timeout);
        }


        private string timedCommand(string _cmd, int _subIp, int _timeoutms)
        {

            string preCommand = "";
            preCommand += "cmd_" + _cmd + ".js ";
            preCommand += "" + public3I_Ip + (_subIp > 1 ? _subIp.ToString() : "*");

            string output = "...";

            try
            {
                string cibleDirectoryESPCOM = node_ESP_COM_repository;

                Process P = new Process();
                P.StartInfo.WorkingDirectory = cibleDirectoryESPCOM;
                P.StartInfo.FileName = "node.exe";
                P.StartInfo.Arguments = preCommand;
                P.StartInfo.RedirectStandardOutput = true;
                P.StartInfo.RedirectStandardInput = true;
                P.StartInfo.UseShellExecute = false;
                //P.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                //P.StartInfo.CreateNoWindow = true;
                P.Start();

                //var output = P.StandardOutput.ReadToEndAsync();

                /////////////// output = exeAsyncProcess(P, _timeoutms);


                ReadLineDelegate d = P.StandardOutput.ReadToEnd;

                IAsyncResult result = d.BeginInvoke(null, null);
                result.AsyncWaitHandle.WaitOne(_timeoutms);

                if (result.IsCompleted)
                {
                    string resultstr = d.EndInvoke(result);
                    output = resultstr;
                    Console.WriteLine("out delgt: " + output);

                    P.Kill();
                    P.Close();
                }
                else
                {
                    Console.WriteLine("Timed out!");

                    P.Kill();
                    P.Close();

                    throw new TimeoutException("Timed Out!");
                }

                Console.WriteLine("out: " + output);
            }
            catch (Exception e)
            {
                Console.WriteLine("ERR CMD: node.exe -- " + preCommand);
                Console.WriteLine(":: " + e.ToString());
            };

            Console.WriteLine(output);

            return output;
        }


    }
}
